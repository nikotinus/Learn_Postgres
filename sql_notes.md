there are several interesting functions in postgresql:

- *group by cube (аттр1, аттр2 и т.д.)* - выводит информацию для всех возможных сочетаний внутри группы:
аттр1 аттр2
null аттр2
аттр1 null
null null
- *group by rollup (attr1, attr2 ...)* - убирает сочетания по одному, начиная справа:
attr1 attr2
att1 null
null null

- *group by groupingsets ((attr1, attr2), ())* - группирует по заданным сетам:
attr1 attr2
null null

если задать **group by groupingsets ((attr1, attr2))** - это будет эквивалетно **group by attr1, attr2**


##CHAPTER5. UNION, INTERSECTION, EXCEPT. All of mentioned previously with ALL.

###Дубликаты строк (5/8)

По умолчанию UNION, INTERSECT и EXCEPT исключают дубликаты строк. Это работает так же, как и добавление DISTINCT после ключевого слова SELECT.

Посмотрим на несколько запросов.

    SELECT value
      FROM table1
    #	value
    1	1
    2	1
    3	3
    4	3
    5	3
    6	5
    SELECT value
      FROM table2
 
    #	value
    1	2
    2	3
    3	3
    4	4
Обрати внимание на намеренно задублированные строки. Теперь посмотрим на результаты операций над множествами:

    SELECT value
      FROM table1
    UNION
    SELECT value
    FROM table2

    #	value
    1	1
    2	2
    3	3
    4	4
    5	5

    SELECT value
     FROM table1
    INTERSECT
    SELECT value
    FROM table2

#	value
1	3
SELECT value
  FROM table1
EXCEPT
SELECT value
  FROM table2
#	value
1	1
2	5
Дубликаты строк отсутствуют независимо от того, были они в исходных таблицах, или получились в результате операции над множествами.

Чтобы СУБД не исключала из результата задублированные строки, нужно к ключевому слову операции над множествами добавить ALL. Перепишем наши запросы и посмотрим на результат:

SELECT value
  FROM table1
 UNION ALL
SELECT value
  FROM table2
#	value
1	1
2	1
3	2
4	3
5	3
6	3
7	3
8	3
9	4
10	5
В результате присутствуют все строки table1 и table2.

SELECT value
  FROM table1
INTERSECT ALL
SELECT value
  FROM table2
#	value
1	3
2	3
Пересечение выдает довольно интересный результат. В table1 значение 3 встречается три раза, а в table2 значение 3 встречается два раза. В результате выполнения запроса мы видим две строки со значением 3. INTERSECT ALL оставляет столько копий одинаковых строк, сколько их встретилось в обеих таблицах (наименьшее количество из двух таблиц). Например, если бы в первой таблице значение 9 встречалось 10 раз, а во второй 15 раз, то в результате INTERSECT ALL значение 9 встретилось 10 раз. Не веришь - проверь самостоятельно :)

SELECT value
  FROM table1
EXCEPT ALL
SELECT value
  FROM table2
#	value
1	1
2	1
3	3
4	5
Откуда появилось значение 3 в результате? При EXCEPT такого не было. EXCEPT ALL исключает из результатов первого запроса столько одинаковых строк, сколько найдет в результате выполнения второго запроса. Разберем каждое значение из table1:

Значение 1 в table1 встречается 2 раза, в table2 ни разу. В результате видим 2 строки со значением 1.
Значение 3 в table1 встречается 3 раза, в table2 2 раза. Из трех строк были исключены две, в результате осталась одна.
Значение 5 в table1 встречается 1 раз, в table2 ни разу. В результате видим 1 строку со значением 5.

iTO_CHAR - форматирование числа (13/13)

Для преобразования числа в строку с заданным форматом используют функцию TO_CHAR:

to_char (число, формат)
Например:

SELECT to_char (12345, '99999990.00') AS "99999990.00",
       to_char (12345, 'S99999990.00') AS "S99999990.00",
       to_char (-12345, 'S99999990.00') AS "S99999990.00",
       to_char (12345, 'S99G999G990D00') AS "S99G999G990D00"
#	99999990.00	S99999990.00	S99999990.00	S99G999G990D00
1	12345.00	+12345.00	-12345.00	+12,345.00
Формат числа задается кодами форматирования

Код	Описание
9	позиция цифры (может отсутствовать, если цифра незначащая)
0	позиция цифры (присутствует всегда, даже если цифра незначащая)
. (точка)	десятичная точка
, (запятая)	разделитель групп (тысяч)
PR	отрицательное значение в угловых скобках
S	знак, добавляемый к числу (с учётом локали)
L	символ денежной единицы (с учётом локали)
D	разделитель целой и дробной части числа (с учётом локали)
G	разделитель групп (с учётом локали)
MI	знак минус в заданной позиции (если число < 0)
PL	знак плюс в заданной позиции (если число > 0)
SG	знак плюс или минус в заданной позиции
RN	число римскими цифрами (в диапазоне от 1 до 3999)
TH или th	окончание порядкового числительного
V	сдвиг на заданное количество цифр
EEEE	экспоненциальная запись числа
FM	подавляет дополнение пробелами
Из этого многообразия обычно используют только

Код	Описание
9	позиция цифры (может отсутствовать, если цифра незначащая)
0	позиция цифры (присутствует всегда, даже если цифра незначащая)
D	разделитель целой и дробной части числа (с учётом локали)
G	разделитель групп (с учётом локали)
Пройдемся по ним.

9 - позиция цифры. Может отсутствовать, если цифра незначащая.

Если на позиции 9-ки в числе есть значащая цифра, то она отображается, если нет, то не отображается.

На примерах будет понятнее.

SELECT to_char (12, '999')
#	to_char
1	12
Если дробную часть не указали в формате, то она не отображается:

SELECT to_char (12.345, '999')
#	to_char
1	12
Дробная часть в формате начинается после точки . или символа D:

SELECT to_char (12.345, '999.9')
#	to_char
1	12.3
Мы указали одну 9-ку после запятой, поэтому в отформатированном числе видим после запятой только десятки.

SELECT to_char (0.12345, '999.99')
#	to_char
1	.12
Интересный момент: при форматировании числа цифры, выходящие за формат, не отбрасываются. Число сначала округляется до указанной в формате точности:

SELECT to_char (12.457, '999.99')
#	to_char
1	12.46
Можно было ожидать, что в результате получим 12.45. Но так как на позиции тысячных стоит 7, то после округления получаем 12.46

0 - позиция цифры. Отображается всегда.

Если в формате числа встретился 0, то цифра всегда отображается:

SELECT to_char (12, '00') AS "00", 
       to_char (12, '000000') AS "000000"
#	00	000000
1	12	000012
SELECT to_char (0.12345, '999.99') as "999.99",
       to_char (0.12345, '990.99') as "990.99"
#	999.99	990.99
1	.12	0.12
D - разделитель целой и дробной части

Разделитель целой и дробной части нужен для указания, сколько знаков после запятой нужно отобразить:

SELECT to_char (123.4567, '999D0') AS "999D0", 
       to_char (123.4567, '999D00') AS "999D00"
#	999D0	999D00
1	123.5	123.46
G - разделитель групп

На месте G в формате числа вставляется символ разделителя групп. Обычно его используют для отделения тысяч, миллионов, миллиардов...

SELECT to_char (1234567.89, '9G999G999D00')
#	to_char
1	1,234,567.89
Но ни что не мешает использовать его в произвольном месте:

SELECT to_char (12345, '999G9G9')
#	to_char
1	123,4,5
Если число не входит в формат

Если в формате числа указать меньше цифр, чем значащих цифр в самом числе, то в результате получим строку из # по формату:

SELECT to_char (123, '9D99'),
       to_char (123, '90')
#	to_char	to_char
1	#.##	##
FM - отбрасываем пробелы в начале строки

Посмотрим на строку результата, когда в формате указано больше 9-к, чем в самом числе. Для наглядности заменим в результате пробелы на точки.

SELECT '#' || to_char(12, '999') AS result,
       length(to_char(12, '999')) AS length,
       translate(to_char(12, '999'), ' ', '.') AS translated
#	result	length	translated
1	# 12	4	..12
Ух, совсем ничего не понятно... Откуда взялись пробелы? Почему в формате указано три символа, а в результате получилась строка из четырех символов?

Если в формате указано больше цифр, чем в числе, то лишние 9-ки в формате заменяются на пробел, а 0 - на 0.

Откуда взялся еще один пробел? Он резервируется под знак числа. Выполним еще один запрос для подтверждения:

SELECT to_char(1, '999') AS result_9,
       length(to_char(1, '999')) AS length_9,
       translate(to_char(1, '999'), ' ', '.') AS translated_9,
       to_char(1, '000') AS result_0,
       length(to_char(1, '000')) AS length_0,
       translate(to_char(1, '000'), ' ', '.') AS translated_0,
       to_char(1, 'S999') AS result_sign,
       length(to_char(1, 'S999')) AS length_sign,
       translate(to_char(1, 'S999'), ' ', '.') AS translated_sign
#	result_9	length_9	translated_9	result_0	length_0	translated_0	result_sign	length_sign	translated_sign
1	1	4	...1	001	4	.001	+1	4	..+1
Добавим в формате модификатор FM:

SELECT to_char(1, 'FM999') AS result_9,
       length(to_char(1, 'FM999')) AS length_9,
       translate(to_char(1, 'FM999'), ' ', '.') AS translated_9,
       to_char(1, 'FM000') AS result_0,
       length(to_char(1, 'FM000')) AS length_0,
       translate(to_char(1, 'FM000'), ' ', '.') AS translated_0,
       to_char(1, 'FMS999') AS result_sign,
       length(to_char(1, 'FMS999')) AS length_sign,
       translate(to_char(1, 'FMS999'), ' ', '.') AS translated_sign
#	result_9	length_9	translated_9	result_0	length_0	translated_0	result_sign	length_sign	translated_sign
1	1	1	1	001	3	001	+1	2	+1
В результате запроса видно, что все дополнительные пробелы были отброшены.
